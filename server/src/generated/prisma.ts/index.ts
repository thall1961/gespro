// Code generated by Prisma (prisma@1.29.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  alcance: (where?: AlcanceWhereInput) => Promise<boolean>;
  anno: (where?: AnnoWhereInput) => Promise<boolean>;
  area: (where?: AreaWhereInput) => Promise<boolean>;
  eje: (where?: EjeWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  integrante: (where?: IntegranteWhereInput) => Promise<boolean>;
  linea: (where?: LineaWhereInput) => Promise<boolean>;
  mes: (where?: MesWhereInput) => Promise<boolean>;
  pago: (where?: PagoWhereInput) => Promise<boolean>;
  proyecto: (where?: ProyectoWhereInput) => Promise<boolean>;
  role: (where?: RoleWhereInput) => Promise<boolean>;
  tipo: (where?: TipoWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  alcance: (where: AlcanceWhereUniqueInput) => AlcancePromise;
  alcances: (
    args?: {
      where?: AlcanceWhereInput;
      orderBy?: AlcanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Alcance>;
  alcancesConnection: (
    args?: {
      where?: AlcanceWhereInput;
      orderBy?: AlcanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AlcanceConnectionPromise;
  anno: (where: AnnoWhereUniqueInput) => AnnoPromise;
  annoes: (
    args?: {
      where?: AnnoWhereInput;
      orderBy?: AnnoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Anno>;
  annoesConnection: (
    args?: {
      where?: AnnoWhereInput;
      orderBy?: AnnoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AnnoConnectionPromise;
  area: (where: AreaWhereUniqueInput) => AreaPromise;
  areas: (
    args?: {
      where?: AreaWhereInput;
      orderBy?: AreaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Area>;
  areasConnection: (
    args?: {
      where?: AreaWhereInput;
      orderBy?: AreaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AreaConnectionPromise;
  eje: (where: EjeWhereUniqueInput) => EjePromise;
  ejes: (
    args?: {
      where?: EjeWhereInput;
      orderBy?: EjeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Eje>;
  ejesConnection: (
    args?: {
      where?: EjeWhereInput;
      orderBy?: EjeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EjeConnectionPromise;
  file: (where: FileWhereUniqueInput) => FilePromise;
  files: (
    args?: {
      where?: FileWhereInput;
      orderBy?: FileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<File>;
  filesConnection: (
    args?: {
      where?: FileWhereInput;
      orderBy?: FileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FileConnectionPromise;
  integrante: (where: IntegranteWhereUniqueInput) => IntegrantePromise;
  integrantes: (
    args?: {
      where?: IntegranteWhereInput;
      orderBy?: IntegranteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Integrante>;
  integrantesConnection: (
    args?: {
      where?: IntegranteWhereInput;
      orderBy?: IntegranteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => IntegranteConnectionPromise;
  linea: (where: LineaWhereUniqueInput) => LineaPromise;
  lineas: (
    args?: {
      where?: LineaWhereInput;
      orderBy?: LineaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Linea>;
  lineasConnection: (
    args?: {
      where?: LineaWhereInput;
      orderBy?: LineaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LineaConnectionPromise;
  mes: (where: MesWhereUniqueInput) => MesPromise;
  meses: (
    args?: {
      where?: MesWhereInput;
      orderBy?: MesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Mes>;
  mesesConnection: (
    args?: {
      where?: MesWhereInput;
      orderBy?: MesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MesConnectionPromise;
  pago: (where: PagoWhereUniqueInput) => PagoPromise;
  pagoes: (
    args?: {
      where?: PagoWhereInput;
      orderBy?: PagoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Pago>;
  pagoesConnection: (
    args?: {
      where?: PagoWhereInput;
      orderBy?: PagoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PagoConnectionPromise;
  proyecto: (where: ProyectoWhereUniqueInput) => ProyectoPromise;
  proyectoes: (
    args?: {
      where?: ProyectoWhereInput;
      orderBy?: ProyectoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Proyecto>;
  proyectoesConnection: (
    args?: {
      where?: ProyectoWhereInput;
      orderBy?: ProyectoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProyectoConnectionPromise;
  role: (where: RoleWhereUniqueInput) => RolePromise;
  roles: (
    args?: {
      where?: RoleWhereInput;
      orderBy?: RoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Role>;
  rolesConnection: (
    args?: {
      where?: RoleWhereInput;
      orderBy?: RoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RoleConnectionPromise;
  tipo: (where: TipoWhereUniqueInput) => TipoPromise;
  tipoes: (
    args?: {
      where?: TipoWhereInput;
      orderBy?: TipoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Tipo>;
  tipoesConnection: (
    args?: {
      where?: TipoWhereInput;
      orderBy?: TipoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TipoConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAlcance: (data: AlcanceCreateInput) => AlcancePromise;
  updateAlcance: (
    args: { data: AlcanceUpdateInput; where: AlcanceWhereUniqueInput }
  ) => AlcancePromise;
  updateManyAlcances: (
    args: { data: AlcanceUpdateManyMutationInput; where?: AlcanceWhereInput }
  ) => BatchPayloadPromise;
  upsertAlcance: (
    args: {
      where: AlcanceWhereUniqueInput;
      create: AlcanceCreateInput;
      update: AlcanceUpdateInput;
    }
  ) => AlcancePromise;
  deleteAlcance: (where: AlcanceWhereUniqueInput) => AlcancePromise;
  deleteManyAlcances: (where?: AlcanceWhereInput) => BatchPayloadPromise;
  createAnno: (data: AnnoCreateInput) => AnnoPromise;
  updateAnno: (
    args: { data: AnnoUpdateInput; where: AnnoWhereUniqueInput }
  ) => AnnoPromise;
  updateManyAnnoes: (
    args: { data: AnnoUpdateManyMutationInput; where?: AnnoWhereInput }
  ) => BatchPayloadPromise;
  upsertAnno: (
    args: {
      where: AnnoWhereUniqueInput;
      create: AnnoCreateInput;
      update: AnnoUpdateInput;
    }
  ) => AnnoPromise;
  deleteAnno: (where: AnnoWhereUniqueInput) => AnnoPromise;
  deleteManyAnnoes: (where?: AnnoWhereInput) => BatchPayloadPromise;
  createArea: (data: AreaCreateInput) => AreaPromise;
  updateArea: (
    args: { data: AreaUpdateInput; where: AreaWhereUniqueInput }
  ) => AreaPromise;
  updateManyAreas: (
    args: { data: AreaUpdateManyMutationInput; where?: AreaWhereInput }
  ) => BatchPayloadPromise;
  upsertArea: (
    args: {
      where: AreaWhereUniqueInput;
      create: AreaCreateInput;
      update: AreaUpdateInput;
    }
  ) => AreaPromise;
  deleteArea: (where: AreaWhereUniqueInput) => AreaPromise;
  deleteManyAreas: (where?: AreaWhereInput) => BatchPayloadPromise;
  createEje: (data: EjeCreateInput) => EjePromise;
  updateEje: (
    args: { data: EjeUpdateInput; where: EjeWhereUniqueInput }
  ) => EjePromise;
  updateManyEjes: (
    args: { data: EjeUpdateManyMutationInput; where?: EjeWhereInput }
  ) => BatchPayloadPromise;
  upsertEje: (
    args: {
      where: EjeWhereUniqueInput;
      create: EjeCreateInput;
      update: EjeUpdateInput;
    }
  ) => EjePromise;
  deleteEje: (where: EjeWhereUniqueInput) => EjePromise;
  deleteManyEjes: (where?: EjeWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (
    args: { data: FileUpdateInput; where: FileWhereUniqueInput }
  ) => FilePromise;
  updateManyFiles: (
    args: { data: FileUpdateManyMutationInput; where?: FileWhereInput }
  ) => BatchPayloadPromise;
  upsertFile: (
    args: {
      where: FileWhereUniqueInput;
      create: FileCreateInput;
      update: FileUpdateInput;
    }
  ) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createIntegrante: (data: IntegranteCreateInput) => IntegrantePromise;
  updateIntegrante: (
    args: { data: IntegranteUpdateInput; where: IntegranteWhereUniqueInput }
  ) => IntegrantePromise;
  updateManyIntegrantes: (
    args: {
      data: IntegranteUpdateManyMutationInput;
      where?: IntegranteWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertIntegrante: (
    args: {
      where: IntegranteWhereUniqueInput;
      create: IntegranteCreateInput;
      update: IntegranteUpdateInput;
    }
  ) => IntegrantePromise;
  deleteIntegrante: (where: IntegranteWhereUniqueInput) => IntegrantePromise;
  deleteManyIntegrantes: (where?: IntegranteWhereInput) => BatchPayloadPromise;
  createLinea: (data: LineaCreateInput) => LineaPromise;
  updateLinea: (
    args: { data: LineaUpdateInput; where: LineaWhereUniqueInput }
  ) => LineaPromise;
  updateManyLineas: (
    args: { data: LineaUpdateManyMutationInput; where?: LineaWhereInput }
  ) => BatchPayloadPromise;
  upsertLinea: (
    args: {
      where: LineaWhereUniqueInput;
      create: LineaCreateInput;
      update: LineaUpdateInput;
    }
  ) => LineaPromise;
  deleteLinea: (where: LineaWhereUniqueInput) => LineaPromise;
  deleteManyLineas: (where?: LineaWhereInput) => BatchPayloadPromise;
  createMes: (data: MesCreateInput) => MesPromise;
  updateMes: (
    args: { data: MesUpdateInput; where: MesWhereUniqueInput }
  ) => MesPromise;
  updateManyMeses: (
    args: { data: MesUpdateManyMutationInput; where?: MesWhereInput }
  ) => BatchPayloadPromise;
  upsertMes: (
    args: {
      where: MesWhereUniqueInput;
      create: MesCreateInput;
      update: MesUpdateInput;
    }
  ) => MesPromise;
  deleteMes: (where: MesWhereUniqueInput) => MesPromise;
  deleteManyMeses: (where?: MesWhereInput) => BatchPayloadPromise;
  createPago: (data: PagoCreateInput) => PagoPromise;
  updatePago: (
    args: { data: PagoUpdateInput; where: PagoWhereUniqueInput }
  ) => PagoPromise;
  updateManyPagoes: (
    args: { data: PagoUpdateManyMutationInput; where?: PagoWhereInput }
  ) => BatchPayloadPromise;
  upsertPago: (
    args: {
      where: PagoWhereUniqueInput;
      create: PagoCreateInput;
      update: PagoUpdateInput;
    }
  ) => PagoPromise;
  deletePago: (where: PagoWhereUniqueInput) => PagoPromise;
  deleteManyPagoes: (where?: PagoWhereInput) => BatchPayloadPromise;
  createProyecto: (data: ProyectoCreateInput) => ProyectoPromise;
  updateProyecto: (
    args: { data: ProyectoUpdateInput; where: ProyectoWhereUniqueInput }
  ) => ProyectoPromise;
  updateManyProyectoes: (
    args: { data: ProyectoUpdateManyMutationInput; where?: ProyectoWhereInput }
  ) => BatchPayloadPromise;
  upsertProyecto: (
    args: {
      where: ProyectoWhereUniqueInput;
      create: ProyectoCreateInput;
      update: ProyectoUpdateInput;
    }
  ) => ProyectoPromise;
  deleteProyecto: (where: ProyectoWhereUniqueInput) => ProyectoPromise;
  deleteManyProyectoes: (where?: ProyectoWhereInput) => BatchPayloadPromise;
  createRole: (data: RoleCreateInput) => RolePromise;
  updateRole: (
    args: { data: RoleUpdateInput; where: RoleWhereUniqueInput }
  ) => RolePromise;
  updateManyRoles: (
    args: { data: RoleUpdateManyMutationInput; where?: RoleWhereInput }
  ) => BatchPayloadPromise;
  upsertRole: (
    args: {
      where: RoleWhereUniqueInput;
      create: RoleCreateInput;
      update: RoleUpdateInput;
    }
  ) => RolePromise;
  deleteRole: (where: RoleWhereUniqueInput) => RolePromise;
  deleteManyRoles: (where?: RoleWhereInput) => BatchPayloadPromise;
  createTipo: (data: TipoCreateInput) => TipoPromise;
  updateTipo: (
    args: { data: TipoUpdateInput; where: TipoWhereUniqueInput }
  ) => TipoPromise;
  updateManyTipoes: (
    args: { data: TipoUpdateManyMutationInput; where?: TipoWhereInput }
  ) => BatchPayloadPromise;
  upsertTipo: (
    args: {
      where: TipoWhereUniqueInput;
      create: TipoCreateInput;
      update: TipoUpdateInput;
    }
  ) => TipoPromise;
  deleteTipo: (where: TipoWhereUniqueInput) => TipoPromise;
  deleteManyTipoes: (where?: TipoWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  alcance: (
    where?: AlcanceSubscriptionWhereInput
  ) => AlcanceSubscriptionPayloadSubscription;
  anno: (
    where?: AnnoSubscriptionWhereInput
  ) => AnnoSubscriptionPayloadSubscription;
  area: (
    where?: AreaSubscriptionWhereInput
  ) => AreaSubscriptionPayloadSubscription;
  eje: (
    where?: EjeSubscriptionWhereInput
  ) => EjeSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  integrante: (
    where?: IntegranteSubscriptionWhereInput
  ) => IntegranteSubscriptionPayloadSubscription;
  linea: (
    where?: LineaSubscriptionWhereInput
  ) => LineaSubscriptionPayloadSubscription;
  mes: (
    where?: MesSubscriptionWhereInput
  ) => MesSubscriptionPayloadSubscription;
  pago: (
    where?: PagoSubscriptionWhereInput
  ) => PagoSubscriptionPayloadSubscription;
  proyecto: (
    where?: ProyectoSubscriptionWhereInput
  ) => ProyectoSubscriptionPayloadSubscription;
  role: (
    where?: RoleSubscriptionWhereInput
  ) => RoleSubscriptionPayloadSubscription;
  tipo: (
    where?: TipoSubscriptionWhereInput
  ) => TipoSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type IntegranteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "jefeProyecto_ASC"
  | "jefeProyecto_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AreaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "nombre_ASC"
  | "nombre_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "email_ASC"
  | "email_DESC"
  | "firstname_ASC"
  | "firstname_DESC"
  | "lastname_ASC"
  | "lastname_DESC"
  | "fullname_ASC"
  | "fullname_DESC"
  | "employeeNumber_ASC"
  | "employeeNumber_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TipoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "nombre_ASC"
  | "nombre_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RoleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "nombre_ASC"
  | "nombre_DESC"
  | "habilitado_ASC"
  | "habilitado_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MES_ENUM =
  | "ENERO"
  | "FEBRERO"
  | "MARZO"
  | "ABRIL"
  | "MAYO"
  | "JUNIO"
  | "JULIO"
  | "AGOSTO"
  | "SEPTIEMBRE"
  | "OCTUBRE"
  | "NOVIEMBRE"
  | "DICIEMBRE";

export type LineaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "nombre_ASC"
  | "nombre_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EjeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "nombre_ASC"
  | "nombre_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AnnoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "numero_ASC"
  | "numero_DESC"
  | "habilitado_ASC"
  | "habilitado_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "path_ASC"
  | "path_DESC"
  | "filename_ASC"
  | "filename_DESC"
  | "mimetype_ASC"
  | "mimetype_DESC"
  | "encoding_ASC"
  | "encoding_DESC"
  | "size_ASC"
  | "size_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ESTADO = "CREADO" | "HABILITADO" | "CERRADO";

export type PagoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "horas_ASC"
  | "horas_DESC"
  | "presencia_ASC"
  | "presencia_DESC"
  | "incidencia_ASC"
  | "incidencia_DESC"
  | "relevancia_ASC"
  | "relevancia_DESC"
  | "complejidad_ASC"
  | "complejidad_DESC"
  | "gestion_ASC"
  | "gestion_DESC"
  | "vinculacion_ASC"
  | "vinculacion_DESC"
  | "calidad_ASC"
  | "calidad_DESC"
  | "significacion_ASC"
  | "significacion_DESC"
  | "cumplimiento_ASC"
  | "cumplimiento_DESC"
  | "calculo_ASC"
  | "calculo_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AlcanceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "nombre_ASC"
  | "nombre_DESC"
  | "valor_ASC"
  | "valor_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProyectoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "codigo_ASC"
  | "codigo_DESC"
  | "nombre_ASC"
  | "nombre_DESC"
  | "inicia_ASC"
  | "inicia_DESC"
  | "finaliza_ASC"
  | "finaliza_DESC"
  | "estado_ASC"
  | "estado_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface PagoCreateWithoutIntegranteInput {
  mes: MesCreateOneInput;
  anno: AnnoCreateOneInput;
  horas?: Float;
  presencia?: Int;
  incidencia?: Int;
  relevancia?: Int;
  complejidad?: Int;
  gestion?: Int;
  vinculacion?: Int;
  calidad?: Int;
  significacion?: Int;
  cumplimiento?: Int;
  calculo?: Float;
}

export type AlcanceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  nombre?: String;
}>;

export interface LineaUpdateInput {
  nombre?: String;
}

export interface RoleUpdateWithoutUsersDataInput {
  name?: String;
  description?: String;
}

export interface AlcanceCreateInput {
  nombre: String;
  valor: Int;
}

export interface AreaWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  nombre?: String;
  nombre_not?: String;
  nombre_in?: String[] | String;
  nombre_not_in?: String[] | String;
  nombre_lt?: String;
  nombre_lte?: String;
  nombre_gt?: String;
  nombre_gte?: String;
  nombre_contains?: String;
  nombre_not_contains?: String;
  nombre_starts_with?: String;
  nombre_not_starts_with?: String;
  nombre_ends_with?: String;
  nombre_not_ends_with?: String;
  AND?: AreaWhereInput[] | AreaWhereInput;
  OR?: AreaWhereInput[] | AreaWhereInput;
  NOT?: AreaWhereInput[] | AreaWhereInput;
}

export interface AlcanceUpdateInput {
  nombre?: String;
  valor?: Int;
}

export interface RoleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RoleWhereInput;
  AND?: RoleSubscriptionWhereInput[] | RoleSubscriptionWhereInput;
  OR?: RoleSubscriptionWhereInput[] | RoleSubscriptionWhereInput;
  NOT?: RoleSubscriptionWhereInput[] | RoleSubscriptionWhereInput;
}

export interface AlcanceUpdateManyMutationInput {
  nombre?: String;
  valor?: Int;
}

export interface PagoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PagoWhereInput;
  AND?: PagoSubscriptionWhereInput[] | PagoSubscriptionWhereInput;
  OR?: PagoSubscriptionWhereInput[] | PagoSubscriptionWhereInput;
  NOT?: PagoSubscriptionWhereInput[] | PagoSubscriptionWhereInput;
}

export interface MesUpdateManyMutationInput {
  nombre?: MES_ENUM;
  habilitado?: Boolean;
}

export interface MesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MesWhereInput;
  AND?: MesSubscriptionWhereInput[] | MesSubscriptionWhereInput;
  OR?: MesSubscriptionWhereInput[] | MesSubscriptionWhereInput;
  NOT?: MesSubscriptionWhereInput[] | MesSubscriptionWhereInput;
}

export interface MesUpdateInput {
  nombre?: MES_ENUM;
  habilitado?: Boolean;
}

export interface LineaSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LineaWhereInput;
  AND?: LineaSubscriptionWhereInput[] | LineaSubscriptionWhereInput;
  OR?: LineaSubscriptionWhereInput[] | LineaSubscriptionWhereInput;
  NOT?: LineaSubscriptionWhereInput[] | LineaSubscriptionWhereInput;
}

export interface AnnoCreateInput {
  numero: Int;
  habilitado?: Boolean;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FileWhereInput;
  AND?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
  OR?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
  NOT?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
}

export interface AnnoUpdateInput {
  numero?: Int;
  habilitado?: Boolean;
}

export type FileWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AnnoUpdateManyMutationInput {
  numero?: Int;
  habilitado?: Boolean;
}

export interface FileWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  filename?: String;
  filename_not?: String;
  filename_in?: String[] | String;
  filename_not_in?: String[] | String;
  filename_lt?: String;
  filename_lte?: String;
  filename_gt?: String;
  filename_gte?: String;
  filename_contains?: String;
  filename_not_contains?: String;
  filename_starts_with?: String;
  filename_not_starts_with?: String;
  filename_ends_with?: String;
  filename_not_ends_with?: String;
  mimetype?: String;
  mimetype_not?: String;
  mimetype_in?: String[] | String;
  mimetype_not_in?: String[] | String;
  mimetype_lt?: String;
  mimetype_lte?: String;
  mimetype_gt?: String;
  mimetype_gte?: String;
  mimetype_contains?: String;
  mimetype_not_contains?: String;
  mimetype_starts_with?: String;
  mimetype_not_starts_with?: String;
  mimetype_ends_with?: String;
  mimetype_not_ends_with?: String;
  encoding?: String;
  encoding_not?: String;
  encoding_in?: String[] | String;
  encoding_not_in?: String[] | String;
  encoding_lt?: String;
  encoding_lte?: String;
  encoding_gt?: String;
  encoding_gte?: String;
  encoding_contains?: String;
  encoding_not_contains?: String;
  encoding_starts_with?: String;
  encoding_not_starts_with?: String;
  encoding_ends_with?: String;
  encoding_not_ends_with?: String;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  AND?: FileWhereInput[] | FileWhereInput;
  OR?: FileWhereInput[] | FileWhereInput;
  NOT?: FileWhereInput[] | FileWhereInput;
}

export interface AreaCreateInput {
  nombre: String;
}

export interface AnnoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AnnoWhereInput;
  AND?: AnnoSubscriptionWhereInput[] | AnnoSubscriptionWhereInput;
  OR?: AnnoSubscriptionWhereInput[] | AnnoSubscriptionWhereInput;
  NOT?: AnnoSubscriptionWhereInput[] | AnnoSubscriptionWhereInput;
}

export interface AreaUpdateInput {
  nombre?: String;
}

export interface UserUpdateManyMutationInput {
  username?: String;
  email?: String;
  firstname?: String;
  lastname?: String;
  fullname?: String;
  employeeNumber?: String;
}

export interface AreaUpdateManyMutationInput {
  nombre?: String;
}

export interface UserUpdateInput {
  username?: String;
  email?: String;
  firstname?: String;
  lastname?: String;
  fullname?: String;
  employeeNumber?: String;
  roles?: RoleUpdateManyWithoutUsersInput;
  integrantes?: IntegranteUpdateManyWithoutUsuarioInput;
}

export interface EjeCreateInput {
  nombre: String;
}

export interface RoleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  AND?: RoleWhereInput[] | RoleWhereInput;
  OR?: RoleWhereInput[] | RoleWhereInput;
  NOT?: RoleWhereInput[] | RoleWhereInput;
}

export interface EjeUpdateInput {
  nombre?: String;
}

export interface IntegranteWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  usuario?: UserWhereInput;
  proyecto?: ProyectoWhereInput;
  jefeProyecto?: Boolean;
  jefeProyecto_not?: Boolean;
  pagos_every?: PagoWhereInput;
  pagos_some?: PagoWhereInput;
  pagos_none?: PagoWhereInput;
  AND?: IntegranteWhereInput[] | IntegranteWhereInput;
  OR?: IntegranteWhereInput[] | IntegranteWhereInput;
  NOT?: IntegranteWhereInput[] | IntegranteWhereInput;
}

export interface EjeUpdateManyMutationInput {
  nombre?: String;
}

export interface TipoUpdateManyMutationInput {
  nombre?: String;
}

export interface FileCreateInput {
  path: String;
  filename: String;
  mimetype: String;
  encoding: String;
  size: Int;
}

export interface LineaWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  nombre?: String;
  nombre_not?: String;
  nombre_in?: String[] | String;
  nombre_not_in?: String[] | String;
  nombre_lt?: String;
  nombre_lte?: String;
  nombre_gt?: String;
  nombre_gte?: String;
  nombre_contains?: String;
  nombre_not_contains?: String;
  nombre_starts_with?: String;
  nombre_not_starts_with?: String;
  nombre_ends_with?: String;
  nombre_not_ends_with?: String;
  AND?: LineaWhereInput[] | LineaWhereInput;
  OR?: LineaWhereInput[] | LineaWhereInput;
  NOT?: LineaWhereInput[] | LineaWhereInput;
}

export interface FileUpdateInput {
  path?: String;
  filename?: String;
  mimetype?: String;
  encoding?: String;
  size?: Int;
}

export interface PagoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  integrante?: IntegranteWhereInput;
  mes?: MesWhereInput;
  anno?: AnnoWhereInput;
  horas?: Float;
  horas_not?: Float;
  horas_in?: Float[] | Float;
  horas_not_in?: Float[] | Float;
  horas_lt?: Float;
  horas_lte?: Float;
  horas_gt?: Float;
  horas_gte?: Float;
  presencia?: Int;
  presencia_not?: Int;
  presencia_in?: Int[] | Int;
  presencia_not_in?: Int[] | Int;
  presencia_lt?: Int;
  presencia_lte?: Int;
  presencia_gt?: Int;
  presencia_gte?: Int;
  incidencia?: Int;
  incidencia_not?: Int;
  incidencia_in?: Int[] | Int;
  incidencia_not_in?: Int[] | Int;
  incidencia_lt?: Int;
  incidencia_lte?: Int;
  incidencia_gt?: Int;
  incidencia_gte?: Int;
  relevancia?: Int;
  relevancia_not?: Int;
  relevancia_in?: Int[] | Int;
  relevancia_not_in?: Int[] | Int;
  relevancia_lt?: Int;
  relevancia_lte?: Int;
  relevancia_gt?: Int;
  relevancia_gte?: Int;
  complejidad?: Int;
  complejidad_not?: Int;
  complejidad_in?: Int[] | Int;
  complejidad_not_in?: Int[] | Int;
  complejidad_lt?: Int;
  complejidad_lte?: Int;
  complejidad_gt?: Int;
  complejidad_gte?: Int;
  gestion?: Int;
  gestion_not?: Int;
  gestion_in?: Int[] | Int;
  gestion_not_in?: Int[] | Int;
  gestion_lt?: Int;
  gestion_lte?: Int;
  gestion_gt?: Int;
  gestion_gte?: Int;
  vinculacion?: Int;
  vinculacion_not?: Int;
  vinculacion_in?: Int[] | Int;
  vinculacion_not_in?: Int[] | Int;
  vinculacion_lt?: Int;
  vinculacion_lte?: Int;
  vinculacion_gt?: Int;
  vinculacion_gte?: Int;
  calidad?: Int;
  calidad_not?: Int;
  calidad_in?: Int[] | Int;
  calidad_not_in?: Int[] | Int;
  calidad_lt?: Int;
  calidad_lte?: Int;
  calidad_gt?: Int;
  calidad_gte?: Int;
  significacion?: Int;
  significacion_not?: Int;
  significacion_in?: Int[] | Int;
  significacion_not_in?: Int[] | Int;
  significacion_lt?: Int;
  significacion_lte?: Int;
  significacion_gt?: Int;
  significacion_gte?: Int;
  cumplimiento?: Int;
  cumplimiento_not?: Int;
  cumplimiento_in?: Int[] | Int;
  cumplimiento_not_in?: Int[] | Int;
  cumplimiento_lt?: Int;
  cumplimiento_lte?: Int;
  cumplimiento_gt?: Int;
  cumplimiento_gte?: Int;
  calculo?: Float;
  calculo_not?: Float;
  calculo_in?: Float[] | Float;
  calculo_not_in?: Float[] | Float;
  calculo_lt?: Float;
  calculo_lte?: Float;
  calculo_gt?: Float;
  calculo_gte?: Float;
  AND?: PagoWhereInput[] | PagoWhereInput;
  OR?: PagoWhereInput[] | PagoWhereInput;
  NOT?: PagoWhereInput[] | PagoWhereInput;
}

export interface FileUpdateManyMutationInput {
  path?: String;
  filename?: String;
  mimetype?: String;
  encoding?: String;
  size?: Int;
}

export type AnnoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  numero?: Int;
}>;

export interface IntegranteCreateInput {
  usuario: UserCreateOneWithoutIntegrantesInput;
  proyecto: ProyectoCreateOneWithoutIntegrantesInput;
  jefeProyecto?: Boolean;
  pagos?: PagoCreateManyWithoutIntegranteInput;
}

export interface UserUpdateManyDataInput {
  username?: String;
  email?: String;
  firstname?: String;
  lastname?: String;
  fullname?: String;
  employeeNumber?: String;
}

export interface UserCreateOneWithoutIntegrantesInput {
  create?: UserCreateWithoutIntegrantesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  firstname?: String;
  firstname_not?: String;
  firstname_in?: String[] | String;
  firstname_not_in?: String[] | String;
  firstname_lt?: String;
  firstname_lte?: String;
  firstname_gt?: String;
  firstname_gte?: String;
  firstname_contains?: String;
  firstname_not_contains?: String;
  firstname_starts_with?: String;
  firstname_not_starts_with?: String;
  firstname_ends_with?: String;
  firstname_not_ends_with?: String;
  lastname?: String;
  lastname_not?: String;
  lastname_in?: String[] | String;
  lastname_not_in?: String[] | String;
  lastname_lt?: String;
  lastname_lte?: String;
  lastname_gt?: String;
  lastname_gte?: String;
  lastname_contains?: String;
  lastname_not_contains?: String;
  lastname_starts_with?: String;
  lastname_not_starts_with?: String;
  lastname_ends_with?: String;
  lastname_not_ends_with?: String;
  fullname?: String;
  fullname_not?: String;
  fullname_in?: String[] | String;
  fullname_not_in?: String[] | String;
  fullname_lt?: String;
  fullname_lte?: String;
  fullname_gt?: String;
  fullname_gte?: String;
  fullname_contains?: String;
  fullname_not_contains?: String;
  fullname_starts_with?: String;
  fullname_not_starts_with?: String;
  fullname_ends_with?: String;
  fullname_not_ends_with?: String;
  employeeNumber?: String;
  employeeNumber_not?: String;
  employeeNumber_in?: String[] | String;
  employeeNumber_not_in?: String[] | String;
  employeeNumber_lt?: String;
  employeeNumber_lte?: String;
  employeeNumber_gt?: String;
  employeeNumber_gte?: String;
  employeeNumber_contains?: String;
  employeeNumber_not_contains?: String;
  employeeNumber_starts_with?: String;
  employeeNumber_not_starts_with?: String;
  employeeNumber_ends_with?: String;
  employeeNumber_not_ends_with?: String;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface UserCreateWithoutIntegrantesInput {
  username: String;
  email: String;
  firstname: String;
  lastname: String;
  fullname: String;
  employeeNumber: String;
  roles?: RoleCreateManyWithoutUsersInput;
}

export interface IntegranteUpsertWithWhereUniqueWithoutUsuarioInput {
  where: IntegranteWhereUniqueInput;
  update: IntegranteUpdateWithoutUsuarioDataInput;
  create: IntegranteCreateWithoutUsuarioInput;
}

export interface RoleCreateManyWithoutUsersInput {
  create?: RoleCreateWithoutUsersInput[] | RoleCreateWithoutUsersInput;
  connect?: RoleWhereUniqueInput[] | RoleWhereUniqueInput;
}

export interface IntegranteUpdateWithWhereUniqueWithoutUsuarioInput {
  where: IntegranteWhereUniqueInput;
  data: IntegranteUpdateWithoutUsuarioDataInput;
}

export interface RoleCreateWithoutUsersInput {
  name: String;
  description?: String;
}

export interface UserUpdateWithoutRolesDataInput {
  username?: String;
  email?: String;
  firstname?: String;
  lastname?: String;
  fullname?: String;
  employeeNumber?: String;
  integrantes?: IntegranteUpdateManyWithoutUsuarioInput;
}

export interface ProyectoCreateOneWithoutIntegrantesInput {
  create?: ProyectoCreateWithoutIntegrantesInput;
  connect?: ProyectoWhereUniqueInput;
}

export interface UserUpdateManyWithoutRolesInput {
  create?: UserCreateWithoutRolesInput[] | UserCreateWithoutRolesInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutRolesInput[]
    | UserUpdateWithWhereUniqueWithoutRolesInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutRolesInput[]
    | UserUpsertWithWhereUniqueWithoutRolesInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface ProyectoCreateWithoutIntegrantesInput {
  codigo: String;
  nombre: String;
  inicia: DateTimeInput;
  finaliza: DateTimeInput;
  area: AreaCreateOneInput;
  tipo: TipoCreateOneInput;
  linea: LineaCreateOneInput;
  eje: EjeCreateOneInput;
  alcance: AlcanceCreateOneInput;
  estado: ESTADO;
}

export interface IntegranteCreateWithoutUsuarioInput {
  proyecto: ProyectoCreateOneWithoutIntegrantesInput;
  jefeProyecto?: Boolean;
  pagos?: PagoCreateManyWithoutIntegranteInput;
}

export interface AreaCreateOneInput {
  create?: AreaCreateInput;
  connect?: AreaWhereUniqueInput;
}

export interface IntegranteCreateManyWithoutUsuarioInput {
  create?:
    | IntegranteCreateWithoutUsuarioInput[]
    | IntegranteCreateWithoutUsuarioInput;
  connect?: IntegranteWhereUniqueInput[] | IntegranteWhereUniqueInput;
}

export interface TipoCreateOneInput {
  create?: TipoCreateInput;
  connect?: TipoWhereUniqueInput;
}

export interface UserCreateManyWithoutRolesInput {
  create?: UserCreateWithoutRolesInput[] | UserCreateWithoutRolesInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface TipoCreateInput {
  nombre: String;
}

export type MesWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  nombre?: MES_ENUM;
}>;

export interface LineaCreateOneInput {
  create?: LineaCreateInput;
  connect?: LineaWhereUniqueInput;
}

export interface ProyectoUpdateManyMutationInput {
  codigo?: String;
  nombre?: String;
  inicia?: DateTimeInput;
  finaliza?: DateTimeInput;
  estado?: ESTADO;
}

export interface LineaCreateInput {
  nombre: String;
}

export interface IntegranteUpdateManyWithWhereNestedInput {
  where: IntegranteScalarWhereInput;
  data: IntegranteUpdateManyDataInput;
}

export interface EjeCreateOneInput {
  create?: EjeCreateInput;
  connect?: EjeWhereUniqueInput;
}

export interface IntegranteScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  jefeProyecto?: Boolean;
  jefeProyecto_not?: Boolean;
  AND?: IntegranteScalarWhereInput[] | IntegranteScalarWhereInput;
  OR?: IntegranteScalarWhereInput[] | IntegranteScalarWhereInput;
  NOT?: IntegranteScalarWhereInput[] | IntegranteScalarWhereInput;
}

export interface AlcanceCreateOneInput {
  create?: AlcanceCreateInput;
  connect?: AlcanceWhereUniqueInput;
}

export interface IntegranteUpdateWithoutProyectoDataInput {
  usuario?: UserUpdateOneRequiredWithoutIntegrantesInput;
  jefeProyecto?: Boolean;
  pagos?: PagoUpdateManyWithoutIntegranteInput;
}

export interface PagoCreateManyWithoutIntegranteInput {
  create?:
    | PagoCreateWithoutIntegranteInput[]
    | PagoCreateWithoutIntegranteInput;
  connect?: PagoWhereUniqueInput[] | PagoWhereUniqueInput;
}

export interface IntegranteUpdateWithWhereUniqueWithoutProyectoInput {
  where: IntegranteWhereUniqueInput;
  data: IntegranteUpdateWithoutProyectoDataInput;
}

export interface LineaUpdateManyMutationInput {
  nombre?: String;
}

export interface ProyectoUpdateInput {
  codigo?: String;
  nombre?: String;
  inicia?: DateTimeInput;
  finaliza?: DateTimeInput;
  area?: AreaUpdateOneRequiredInput;
  tipo?: TipoUpdateOneRequiredInput;
  linea?: LineaUpdateOneRequiredInput;
  eje?: EjeUpdateOneRequiredInput;
  alcance?: AlcanceUpdateOneRequiredInput;
  estado?: ESTADO;
  integrantes?: IntegranteUpdateManyWithoutProyectoInput;
}

export interface MesCreateOneInput {
  create?: MesCreateInput;
  connect?: MesWhereUniqueInput;
}

export type RoleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface MesCreateInput {
  nombre: MES_ENUM;
  habilitado?: Boolean;
}

export interface ProyectoCreateInput {
  codigo: String;
  nombre: String;
  inicia: DateTimeInput;
  finaliza: DateTimeInput;
  area: AreaCreateOneInput;
  tipo: TipoCreateOneInput;
  linea: LineaCreateOneInput;
  eje: EjeCreateOneInput;
  alcance: AlcanceCreateOneInput;
  estado: ESTADO;
  integrantes?: IntegranteCreateManyWithoutProyectoInput;
}

export interface AnnoCreateOneInput {
  create?: AnnoCreateInput;
  connect?: AnnoWhereUniqueInput;
}

export type TipoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  nombre?: String;
}>;

export interface IntegranteUpdateInput {
  usuario?: UserUpdateOneRequiredWithoutIntegrantesInput;
  proyecto?: ProyectoUpdateOneRequiredWithoutIntegrantesInput;
  jefeProyecto?: Boolean;
  pagos?: PagoUpdateManyWithoutIntegranteInput;
}

export interface IntegranteUpdateWithoutPagosDataInput {
  usuario?: UserUpdateOneRequiredWithoutIntegrantesInput;
  proyecto?: ProyectoUpdateOneRequiredWithoutIntegrantesInput;
  jefeProyecto?: Boolean;
}

export interface UserUpdateOneRequiredWithoutIntegrantesInput {
  create?: UserCreateWithoutIntegrantesInput;
  update?: UserUpdateWithoutIntegrantesDataInput;
  upsert?: UserUpsertWithoutIntegrantesInput;
  connect?: UserWhereUniqueInput;
}

export interface PagoUpdateInput {
  integrante?: IntegranteUpdateOneRequiredWithoutPagosInput;
  mes?: MesUpdateOneRequiredInput;
  anno?: AnnoUpdateOneRequiredInput;
  horas?: Float;
  presencia?: Int;
  incidencia?: Int;
  relevancia?: Int;
  complejidad?: Int;
  gestion?: Int;
  vinculacion?: Int;
  calidad?: Int;
  significacion?: Int;
  cumplimiento?: Int;
  calculo?: Float;
}

export interface UserUpdateWithoutIntegrantesDataInput {
  username?: String;
  email?: String;
  firstname?: String;
  lastname?: String;
  fullname?: String;
  employeeNumber?: String;
  roles?: RoleUpdateManyWithoutUsersInput;
}

export interface IntegranteCreateWithoutPagosInput {
  usuario: UserCreateOneWithoutIntegrantesInput;
  proyecto: ProyectoCreateOneWithoutIntegrantesInput;
  jefeProyecto?: Boolean;
}

export interface RoleUpdateManyWithoutUsersInput {
  create?: RoleCreateWithoutUsersInput[] | RoleCreateWithoutUsersInput;
  delete?: RoleWhereUniqueInput[] | RoleWhereUniqueInput;
  connect?: RoleWhereUniqueInput[] | RoleWhereUniqueInput;
  set?: RoleWhereUniqueInput[] | RoleWhereUniqueInput;
  disconnect?: RoleWhereUniqueInput[] | RoleWhereUniqueInput;
  update?:
    | RoleUpdateWithWhereUniqueWithoutUsersInput[]
    | RoleUpdateWithWhereUniqueWithoutUsersInput;
  upsert?:
    | RoleUpsertWithWhereUniqueWithoutUsersInput[]
    | RoleUpsertWithWhereUniqueWithoutUsersInput;
  deleteMany?: RoleScalarWhereInput[] | RoleScalarWhereInput;
  updateMany?:
    | RoleUpdateManyWithWhereNestedInput[]
    | RoleUpdateManyWithWhereNestedInput;
}

export interface PagoCreateInput {
  integrante: IntegranteCreateOneWithoutPagosInput;
  mes: MesCreateOneInput;
  anno: AnnoCreateOneInput;
  horas?: Float;
  presencia?: Int;
  incidencia?: Int;
  relevancia?: Int;
  complejidad?: Int;
  gestion?: Int;
  vinculacion?: Int;
  calidad?: Int;
  significacion?: Int;
  cumplimiento?: Int;
  calculo?: Float;
}

export interface RoleUpdateWithWhereUniqueWithoutUsersInput {
  where: RoleWhereUniqueInput;
  data: RoleUpdateWithoutUsersDataInput;
}

export interface TipoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TipoWhereInput;
  AND?: TipoSubscriptionWhereInput[] | TipoSubscriptionWhereInput;
  OR?: TipoSubscriptionWhereInput[] | TipoSubscriptionWhereInput;
  NOT?: TipoSubscriptionWhereInput[] | TipoSubscriptionWhereInput;
}

export type AreaWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  nombre?: String;
}>;

export type EjeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  nombre?: String;
}>;

export interface RoleUpsertWithWhereUniqueWithoutUsersInput {
  where: RoleWhereUniqueInput;
  update: RoleUpdateWithoutUsersDataInput;
  create: RoleCreateWithoutUsersInput;
}

export interface IntegranteSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: IntegranteWhereInput;
  AND?: IntegranteSubscriptionWhereInput[] | IntegranteSubscriptionWhereInput;
  OR?: IntegranteSubscriptionWhereInput[] | IntegranteSubscriptionWhereInput;
  NOT?: IntegranteSubscriptionWhereInput[] | IntegranteSubscriptionWhereInput;
}

export interface RoleScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: RoleScalarWhereInput[] | RoleScalarWhereInput;
  OR?: RoleScalarWhereInput[] | RoleScalarWhereInput;
  NOT?: RoleScalarWhereInput[] | RoleScalarWhereInput;
}

export interface AreaSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AreaWhereInput;
  AND?: AreaSubscriptionWhereInput[] | AreaSubscriptionWhereInput;
  OR?: AreaSubscriptionWhereInput[] | AreaSubscriptionWhereInput;
  NOT?: AreaSubscriptionWhereInput[] | AreaSubscriptionWhereInput;
}

export interface RoleUpdateManyWithWhereNestedInput {
  where: RoleScalarWhereInput;
  data: RoleUpdateManyDataInput;
}

export interface AlcanceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AlcanceWhereInput;
  AND?: AlcanceSubscriptionWhereInput[] | AlcanceSubscriptionWhereInput;
  OR?: AlcanceSubscriptionWhereInput[] | AlcanceSubscriptionWhereInput;
  NOT?: AlcanceSubscriptionWhereInput[] | AlcanceSubscriptionWhereInput;
}

export interface RoleUpdateManyDataInput {
  name?: String;
  description?: String;
}

export interface UserCreateInput {
  username: String;
  email: String;
  firstname: String;
  lastname: String;
  fullname: String;
  employeeNumber: String;
  roles?: RoleCreateManyWithoutUsersInput;
  integrantes?: IntegranteCreateManyWithoutUsuarioInput;
}

export interface UserUpsertWithoutIntegrantesInput {
  update: UserUpdateWithoutIntegrantesDataInput;
  create: UserCreateWithoutIntegrantesInput;
}

export interface ProyectoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  codigo?: String;
  codigo_not?: String;
  codigo_in?: String[] | String;
  codigo_not_in?: String[] | String;
  codigo_lt?: String;
  codigo_lte?: String;
  codigo_gt?: String;
  codigo_gte?: String;
  codigo_contains?: String;
  codigo_not_contains?: String;
  codigo_starts_with?: String;
  codigo_not_starts_with?: String;
  codigo_ends_with?: String;
  codigo_not_ends_with?: String;
  nombre?: String;
  nombre_not?: String;
  nombre_in?: String[] | String;
  nombre_not_in?: String[] | String;
  nombre_lt?: String;
  nombre_lte?: String;
  nombre_gt?: String;
  nombre_gte?: String;
  nombre_contains?: String;
  nombre_not_contains?: String;
  nombre_starts_with?: String;
  nombre_not_starts_with?: String;
  nombre_ends_with?: String;
  nombre_not_ends_with?: String;
  inicia?: DateTimeInput;
  inicia_not?: DateTimeInput;
  inicia_in?: DateTimeInput[] | DateTimeInput;
  inicia_not_in?: DateTimeInput[] | DateTimeInput;
  inicia_lt?: DateTimeInput;
  inicia_lte?: DateTimeInput;
  inicia_gt?: DateTimeInput;
  inicia_gte?: DateTimeInput;
  finaliza?: DateTimeInput;
  finaliza_not?: DateTimeInput;
  finaliza_in?: DateTimeInput[] | DateTimeInput;
  finaliza_not_in?: DateTimeInput[] | DateTimeInput;
  finaliza_lt?: DateTimeInput;
  finaliza_lte?: DateTimeInput;
  finaliza_gt?: DateTimeInput;
  finaliza_gte?: DateTimeInput;
  area?: AreaWhereInput;
  tipo?: TipoWhereInput;
  linea?: LineaWhereInput;
  eje?: EjeWhereInput;
  alcance?: AlcanceWhereInput;
  estado?: ESTADO;
  estado_not?: ESTADO;
  estado_in?: ESTADO[] | ESTADO;
  estado_not_in?: ESTADO[] | ESTADO;
  integrantes_every?: IntegranteWhereInput;
  integrantes_some?: IntegranteWhereInput;
  integrantes_none?: IntegranteWhereInput;
  AND?: ProyectoWhereInput[] | ProyectoWhereInput;
  OR?: ProyectoWhereInput[] | ProyectoWhereInput;
  NOT?: ProyectoWhereInput[] | ProyectoWhereInput;
}

export interface ProyectoUpdateOneRequiredWithoutIntegrantesInput {
  create?: ProyectoCreateWithoutIntegrantesInput;
  update?: ProyectoUpdateWithoutIntegrantesDataInput;
  upsert?: ProyectoUpsertWithoutIntegrantesInput;
  connect?: ProyectoWhereUniqueInput;
}

export interface TipoUpdateInput {
  nombre?: String;
}

export interface ProyectoUpdateWithoutIntegrantesDataInput {
  codigo?: String;
  nombre?: String;
  inicia?: DateTimeInput;
  finaliza?: DateTimeInput;
  area?: AreaUpdateOneRequiredInput;
  tipo?: TipoUpdateOneRequiredInput;
  linea?: LineaUpdateOneRequiredInput;
  eje?: EjeUpdateOneRequiredInput;
  alcance?: AlcanceUpdateOneRequiredInput;
  estado?: ESTADO;
}

export interface RoleUpdateManyMutationInput {
  name?: String;
  description?: String;
}

export interface AreaUpdateOneRequiredInput {
  create?: AreaCreateInput;
  update?: AreaUpdateDataInput;
  upsert?: AreaUpsertNestedInput;
  connect?: AreaWhereUniqueInput;
}

export interface UserUpsertWithWhereUniqueWithoutRolesInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutRolesDataInput;
  create: UserCreateWithoutRolesInput;
}

export interface AreaUpdateDataInput {
  nombre?: String;
}

export interface IntegranteUpdateManyWithoutUsuarioInput {
  create?:
    | IntegranteCreateWithoutUsuarioInput[]
    | IntegranteCreateWithoutUsuarioInput;
  delete?: IntegranteWhereUniqueInput[] | IntegranteWhereUniqueInput;
  connect?: IntegranteWhereUniqueInput[] | IntegranteWhereUniqueInput;
  set?: IntegranteWhereUniqueInput[] | IntegranteWhereUniqueInput;
  disconnect?: IntegranteWhereUniqueInput[] | IntegranteWhereUniqueInput;
  update?:
    | IntegranteUpdateWithWhereUniqueWithoutUsuarioInput[]
    | IntegranteUpdateWithWhereUniqueWithoutUsuarioInput;
  upsert?:
    | IntegranteUpsertWithWhereUniqueWithoutUsuarioInput[]
    | IntegranteUpsertWithWhereUniqueWithoutUsuarioInput;
  deleteMany?: IntegranteScalarWhereInput[] | IntegranteScalarWhereInput;
  updateMany?:
    | IntegranteUpdateManyWithWhereNestedInput[]
    | IntegranteUpdateManyWithWhereNestedInput;
}

export interface AreaUpsertNestedInput {
  update: AreaUpdateDataInput;
  create: AreaCreateInput;
}

export interface RoleUpdateInput {
  name?: String;
  description?: String;
  users?: UserUpdateManyWithoutRolesInput;
}

export interface TipoUpdateOneRequiredInput {
  create?: TipoCreateInput;
  update?: TipoUpdateDataInput;
  upsert?: TipoUpsertNestedInput;
  connect?: TipoWhereUniqueInput;
}

export interface UserCreateWithoutRolesInput {
  username: String;
  email: String;
  firstname: String;
  lastname: String;
  fullname: String;
  employeeNumber: String;
  integrantes?: IntegranteCreateManyWithoutUsuarioInput;
}

export interface TipoUpdateDataInput {
  nombre?: String;
}

export interface AlcanceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  nombre?: String;
  nombre_not?: String;
  nombre_in?: String[] | String;
  nombre_not_in?: String[] | String;
  nombre_lt?: String;
  nombre_lte?: String;
  nombre_gt?: String;
  nombre_gte?: String;
  nombre_contains?: String;
  nombre_not_contains?: String;
  nombre_starts_with?: String;
  nombre_not_starts_with?: String;
  nombre_ends_with?: String;
  nombre_not_ends_with?: String;
  valor?: Int;
  valor_not?: Int;
  valor_in?: Int[] | Int;
  valor_not_in?: Int[] | Int;
  valor_lt?: Int;
  valor_lte?: Int;
  valor_gt?: Int;
  valor_gte?: Int;
  AND?: AlcanceWhereInput[] | AlcanceWhereInput;
  OR?: AlcanceWhereInput[] | AlcanceWhereInput;
  NOT?: AlcanceWhereInput[] | AlcanceWhereInput;
}

export interface TipoUpsertNestedInput {
  update: TipoUpdateDataInput;
  create: TipoCreateInput;
}

export type PagoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface LineaUpdateOneRequiredInput {
  create?: LineaCreateInput;
  update?: LineaUpdateDataInput;
  upsert?: LineaUpsertNestedInput;
  connect?: LineaWhereUniqueInput;
}

export type ProyectoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  codigo?: String;
  nombre?: String;
}>;

export interface LineaUpdateDataInput {
  nombre?: String;
}

export interface IntegranteCreateWithoutProyectoInput {
  usuario: UserCreateOneWithoutIntegrantesInput;
  jefeProyecto?: Boolean;
  pagos?: PagoCreateManyWithoutIntegranteInput;
}

export interface LineaUpsertNestedInput {
  update: LineaUpdateDataInput;
  create: LineaCreateInput;
}

export interface PagoUpdateManyMutationInput {
  horas?: Float;
  presencia?: Int;
  incidencia?: Int;
  relevancia?: Int;
  complejidad?: Int;
  gestion?: Int;
  vinculacion?: Int;
  calidad?: Int;
  significacion?: Int;
  cumplimiento?: Int;
  calculo?: Float;
}

export interface EjeUpdateOneRequiredInput {
  create?: EjeCreateInput;
  update?: EjeUpdateDataInput;
  upsert?: EjeUpsertNestedInput;
  connect?: EjeWhereUniqueInput;
}

export interface IntegranteUpdateOneRequiredWithoutPagosInput {
  create?: IntegranteCreateWithoutPagosInput;
  update?: IntegranteUpdateWithoutPagosDataInput;
  upsert?: IntegranteUpsertWithoutPagosInput;
  connect?: IntegranteWhereUniqueInput;
}

export interface EjeUpdateDataInput {
  nombre?: String;
}

export interface IntegranteCreateOneWithoutPagosInput {
  create?: IntegranteCreateWithoutPagosInput;
  connect?: IntegranteWhereUniqueInput;
}

export interface EjeUpsertNestedInput {
  update: EjeUpdateDataInput;
  create: EjeCreateInput;
}

export interface ProyectoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProyectoWhereInput;
  AND?: ProyectoSubscriptionWhereInput[] | ProyectoSubscriptionWhereInput;
  OR?: ProyectoSubscriptionWhereInput[] | ProyectoSubscriptionWhereInput;
  NOT?: ProyectoSubscriptionWhereInput[] | ProyectoSubscriptionWhereInput;
}

export interface AlcanceUpdateOneRequiredInput {
  create?: AlcanceCreateInput;
  update?: AlcanceUpdateDataInput;
  upsert?: AlcanceUpsertNestedInput;
  connect?: AlcanceWhereUniqueInput;
}

export interface EjeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EjeWhereInput;
  AND?: EjeSubscriptionWhereInput[] | EjeSubscriptionWhereInput;
  OR?: EjeSubscriptionWhereInput[] | EjeSubscriptionWhereInput;
  NOT?: EjeSubscriptionWhereInput[] | EjeSubscriptionWhereInput;
}

export interface AlcanceUpdateDataInput {
  nombre?: String;
  valor?: Int;
}

export type IntegranteWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AlcanceUpsertNestedInput {
  update: AlcanceUpdateDataInput;
  create: AlcanceCreateInput;
}

export interface TipoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  nombre?: String;
  nombre_not?: String;
  nombre_in?: String[] | String;
  nombre_not_in?: String[] | String;
  nombre_lt?: String;
  nombre_lte?: String;
  nombre_gt?: String;
  nombre_gte?: String;
  nombre_contains?: String;
  nombre_not_contains?: String;
  nombre_starts_with?: String;
  nombre_not_starts_with?: String;
  nombre_ends_with?: String;
  nombre_not_ends_with?: String;
  AND?: TipoWhereInput[] | TipoWhereInput;
  OR?: TipoWhereInput[] | TipoWhereInput;
  NOT?: TipoWhereInput[] | TipoWhereInput;
}

export interface ProyectoUpsertWithoutIntegrantesInput {
  update: ProyectoUpdateWithoutIntegrantesDataInput;
  create: ProyectoCreateWithoutIntegrantesInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface PagoUpdateManyWithoutIntegranteInput {
  create?:
    | PagoCreateWithoutIntegranteInput[]
    | PagoCreateWithoutIntegranteInput;
  delete?: PagoWhereUniqueInput[] | PagoWhereUniqueInput;
  connect?: PagoWhereUniqueInput[] | PagoWhereUniqueInput;
  set?: PagoWhereUniqueInput[] | PagoWhereUniqueInput;
  disconnect?: PagoWhereUniqueInput[] | PagoWhereUniqueInput;
  update?:
    | PagoUpdateWithWhereUniqueWithoutIntegranteInput[]
    | PagoUpdateWithWhereUniqueWithoutIntegranteInput;
  upsert?:
    | PagoUpsertWithWhereUniqueWithoutIntegranteInput[]
    | PagoUpsertWithWhereUniqueWithoutIntegranteInput;
  deleteMany?: PagoScalarWhereInput[] | PagoScalarWhereInput;
  updateMany?:
    | PagoUpdateManyWithWhereNestedInput[]
    | PagoUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutRolesInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutRolesDataInput;
}

export interface PagoUpdateWithWhereUniqueWithoutIntegranteInput {
  where: PagoWhereUniqueInput;
  data: PagoUpdateWithoutIntegranteDataInput;
}

export interface RoleCreateInput {
  name: String;
  description?: String;
  users?: UserCreateManyWithoutRolesInput;
}

export interface PagoUpdateWithoutIntegranteDataInput {
  mes?: MesUpdateOneRequiredInput;
  anno?: AnnoUpdateOneRequiredInput;
  horas?: Float;
  presencia?: Int;
  incidencia?: Int;
  relevancia?: Int;
  complejidad?: Int;
  gestion?: Int;
  vinculacion?: Int;
  calidad?: Int;
  significacion?: Int;
  cumplimiento?: Int;
  calculo?: Float;
}

export interface IntegranteUpsertWithWhereUniqueWithoutProyectoInput {
  where: IntegranteWhereUniqueInput;
  update: IntegranteUpdateWithoutProyectoDataInput;
  create: IntegranteCreateWithoutProyectoInput;
}

export interface MesUpdateOneRequiredInput {
  create?: MesCreateInput;
  update?: MesUpdateDataInput;
  upsert?: MesUpsertNestedInput;
  connect?: MesWhereUniqueInput;
}

export interface IntegranteCreateManyWithoutProyectoInput {
  create?:
    | IntegranteCreateWithoutProyectoInput[]
    | IntegranteCreateWithoutProyectoInput;
  connect?: IntegranteWhereUniqueInput[] | IntegranteWhereUniqueInput;
}

export interface MesUpdateDataInput {
  nombre?: MES_ENUM;
  habilitado?: Boolean;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  username?: String;
  email?: String;
  employeeNumber?: String;
}>;

export interface MesUpsertNestedInput {
  update: MesUpdateDataInput;
  create: MesCreateInput;
}

export interface EjeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  nombre?: String;
  nombre_not?: String;
  nombre_in?: String[] | String;
  nombre_not_in?: String[] | String;
  nombre_lt?: String;
  nombre_lte?: String;
  nombre_gt?: String;
  nombre_gte?: String;
  nombre_contains?: String;
  nombre_not_contains?: String;
  nombre_starts_with?: String;
  nombre_not_starts_with?: String;
  nombre_ends_with?: String;
  nombre_not_ends_with?: String;
  AND?: EjeWhereInput[] | EjeWhereInput;
  OR?: EjeWhereInput[] | EjeWhereInput;
  NOT?: EjeWhereInput[] | EjeWhereInput;
}

export interface AnnoUpdateOneRequiredInput {
  create?: AnnoCreateInput;
  update?: AnnoUpdateDataInput;
  upsert?: AnnoUpsertNestedInput;
  connect?: AnnoWhereUniqueInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  firstname?: String;
  firstname_not?: String;
  firstname_in?: String[] | String;
  firstname_not_in?: String[] | String;
  firstname_lt?: String;
  firstname_lte?: String;
  firstname_gt?: String;
  firstname_gte?: String;
  firstname_contains?: String;
  firstname_not_contains?: String;
  firstname_starts_with?: String;
  firstname_not_starts_with?: String;
  firstname_ends_with?: String;
  firstname_not_ends_with?: String;
  lastname?: String;
  lastname_not?: String;
  lastname_in?: String[] | String;
  lastname_not_in?: String[] | String;
  lastname_lt?: String;
  lastname_lte?: String;
  lastname_gt?: String;
  lastname_gte?: String;
  lastname_contains?: String;
  lastname_not_contains?: String;
  lastname_starts_with?: String;
  lastname_not_starts_with?: String;
  lastname_ends_with?: String;
  lastname_not_ends_with?: String;
  fullname?: String;
  fullname_not?: String;
  fullname_in?: String[] | String;
  fullname_not_in?: String[] | String;
  fullname_lt?: String;
  fullname_lte?: String;
  fullname_gt?: String;
  fullname_gte?: String;
  fullname_contains?: String;
  fullname_not_contains?: String;
  fullname_starts_with?: String;
  fullname_not_starts_with?: String;
  fullname_ends_with?: String;
  fullname_not_ends_with?: String;
  employeeNumber?: String;
  employeeNumber_not?: String;
  employeeNumber_in?: String[] | String;
  employeeNumber_not_in?: String[] | String;
  employeeNumber_lt?: String;
  employeeNumber_lte?: String;
  employeeNumber_gt?: String;
  employeeNumber_gte?: String;
  employeeNumber_contains?: String;
  employeeNumber_not_contains?: String;
  employeeNumber_starts_with?: String;
  employeeNumber_not_starts_with?: String;
  employeeNumber_ends_with?: String;
  employeeNumber_not_ends_with?: String;
  roles_every?: RoleWhereInput;
  roles_some?: RoleWhereInput;
  roles_none?: RoleWhereInput;
  integrantes_every?: IntegranteWhereInput;
  integrantes_some?: IntegranteWhereInput;
  integrantes_none?: IntegranteWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface AnnoUpdateDataInput {
  numero?: Int;
  habilitado?: Boolean;
}

export interface IntegranteUpdateWithoutUsuarioDataInput {
  proyecto?: ProyectoUpdateOneRequiredWithoutIntegrantesInput;
  jefeProyecto?: Boolean;
  pagos?: PagoUpdateManyWithoutIntegranteInput;
}

export interface AnnoUpsertNestedInput {
  update: AnnoUpdateDataInput;
  create: AnnoCreateInput;
}

export interface IntegranteUpdateManyDataInput {
  jefeProyecto?: Boolean;
}

export interface PagoUpsertWithWhereUniqueWithoutIntegranteInput {
  where: PagoWhereUniqueInput;
  update: PagoUpdateWithoutIntegranteDataInput;
  create: PagoCreateWithoutIntegranteInput;
}

export interface IntegranteUpsertWithoutPagosInput {
  update: IntegranteUpdateWithoutPagosDataInput;
  create: IntegranteCreateWithoutPagosInput;
}

export interface IntegranteUpdateManyMutationInput {
  jefeProyecto?: Boolean;
}

export interface PagoUpdateManyDataInput {
  horas?: Float;
  presencia?: Int;
  incidencia?: Int;
  relevancia?: Int;
  complejidad?: Int;
  gestion?: Int;
  vinculacion?: Int;
  calidad?: Int;
  significacion?: Int;
  cumplimiento?: Int;
  calculo?: Float;
}

export interface PagoUpdateManyWithWhereNestedInput {
  where: PagoScalarWhereInput;
  data: PagoUpdateManyDataInput;
}

export interface PagoScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  horas?: Float;
  horas_not?: Float;
  horas_in?: Float[] | Float;
  horas_not_in?: Float[] | Float;
  horas_lt?: Float;
  horas_lte?: Float;
  horas_gt?: Float;
  horas_gte?: Float;
  presencia?: Int;
  presencia_not?: Int;
  presencia_in?: Int[] | Int;
  presencia_not_in?: Int[] | Int;
  presencia_lt?: Int;
  presencia_lte?: Int;
  presencia_gt?: Int;
  presencia_gte?: Int;
  incidencia?: Int;
  incidencia_not?: Int;
  incidencia_in?: Int[] | Int;
  incidencia_not_in?: Int[] | Int;
  incidencia_lt?: Int;
  incidencia_lte?: Int;
  incidencia_gt?: Int;
  incidencia_gte?: Int;
  relevancia?: Int;
  relevancia_not?: Int;
  relevancia_in?: Int[] | Int;
  relevancia_not_in?: Int[] | Int;
  relevancia_lt?: Int;
  relevancia_lte?: Int;
  relevancia_gt?: Int;
  relevancia_gte?: Int;
  complejidad?: Int;
  complejidad_not?: Int;
  complejidad_in?: Int[] | Int;
  complejidad_not_in?: Int[] | Int;
  complejidad_lt?: Int;
  complejidad_lte?: Int;
  complejidad_gt?: Int;
  complejidad_gte?: Int;
  gestion?: Int;
  gestion_not?: Int;
  gestion_in?: Int[] | Int;
  gestion_not_in?: Int[] | Int;
  gestion_lt?: Int;
  gestion_lte?: Int;
  gestion_gt?: Int;
  gestion_gte?: Int;
  vinculacion?: Int;
  vinculacion_not?: Int;
  vinculacion_in?: Int[] | Int;
  vinculacion_not_in?: Int[] | Int;
  vinculacion_lt?: Int;
  vinculacion_lte?: Int;
  vinculacion_gt?: Int;
  vinculacion_gte?: Int;
  calidad?: Int;
  calidad_not?: Int;
  calidad_in?: Int[] | Int;
  calidad_not_in?: Int[] | Int;
  calidad_lt?: Int;
  calidad_lte?: Int;
  calidad_gt?: Int;
  calidad_gte?: Int;
  significacion?: Int;
  significacion_not?: Int;
  significacion_in?: Int[] | Int;
  significacion_not_in?: Int[] | Int;
  significacion_lt?: Int;
  significacion_lte?: Int;
  significacion_gt?: Int;
  significacion_gte?: Int;
  cumplimiento?: Int;
  cumplimiento_not?: Int;
  cumplimiento_in?: Int[] | Int;
  cumplimiento_not_in?: Int[] | Int;
  cumplimiento_lt?: Int;
  cumplimiento_lte?: Int;
  cumplimiento_gt?: Int;
  cumplimiento_gte?: Int;
  calculo?: Float;
  calculo_not?: Float;
  calculo_in?: Float[] | Float;
  calculo_not_in?: Float[] | Float;
  calculo_lt?: Float;
  calculo_lte?: Float;
  calculo_gt?: Float;
  calculo_gte?: Float;
  AND?: PagoScalarWhereInput[] | PagoScalarWhereInput;
  OR?: PagoScalarWhereInput[] | PagoScalarWhereInput;
  NOT?: PagoScalarWhereInput[] | PagoScalarWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface IntegranteUpdateManyWithoutProyectoInput {
  create?:
    | IntegranteCreateWithoutProyectoInput[]
    | IntegranteCreateWithoutProyectoInput;
  delete?: IntegranteWhereUniqueInput[] | IntegranteWhereUniqueInput;
  connect?: IntegranteWhereUniqueInput[] | IntegranteWhereUniqueInput;
  set?: IntegranteWhereUniqueInput[] | IntegranteWhereUniqueInput;
  disconnect?: IntegranteWhereUniqueInput[] | IntegranteWhereUniqueInput;
  update?:
    | IntegranteUpdateWithWhereUniqueWithoutProyectoInput[]
    | IntegranteUpdateWithWhereUniqueWithoutProyectoInput;
  upsert?:
    | IntegranteUpsertWithWhereUniqueWithoutProyectoInput[]
    | IntegranteUpsertWithWhereUniqueWithoutProyectoInput;
  deleteMany?: IntegranteScalarWhereInput[] | IntegranteScalarWhereInput;
  updateMany?:
    | IntegranteUpdateManyWithWhereNestedInput[]
    | IntegranteUpdateManyWithWhereNestedInput;
}

export type LineaWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  nombre?: String;
}>;

export interface MesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  nombre?: MES_ENUM;
  nombre_not?: MES_ENUM;
  nombre_in?: MES_ENUM[] | MES_ENUM;
  nombre_not_in?: MES_ENUM[] | MES_ENUM;
  habilitado?: Boolean;
  habilitado_not?: Boolean;
  AND?: MesWhereInput[] | MesWhereInput;
  OR?: MesWhereInput[] | MesWhereInput;
  NOT?: MesWhereInput[] | MesWhereInput;
}

export interface AnnoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  numero?: Int;
  numero_not?: Int;
  numero_in?: Int[] | Int;
  numero_not_in?: Int[] | Int;
  numero_lt?: Int;
  numero_lte?: Int;
  numero_gt?: Int;
  numero_gte?: Int;
  habilitado?: Boolean;
  habilitado_not?: Boolean;
  AND?: AnnoWhereInput[] | AnnoWhereInput;
  OR?: AnnoWhereInput[] | AnnoWhereInput;
  NOT?: AnnoWhereInput[] | AnnoWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  username: String;
  email: String;
  firstname: String;
  lastname: String;
  fullname: String;
  employeeNumber: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  fullname: () => Promise<String>;
  employeeNumber: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  firstname: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  fullname: () => Promise<AsyncIterator<String>>;
  employeeNumber: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  username: String;
  email: String;
  firstname: String;
  lastname: String;
  fullname: String;
  employeeNumber: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  fullname: () => Promise<String>;
  employeeNumber: () => Promise<String>;
  roles: <T = FragmentableArray<Role>>(
    args?: {
      where?: RoleWhereInput;
      orderBy?: RoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  integrantes: <T = FragmentableArray<Integrante>>(
    args?: {
      where?: IntegranteWhereInput;
      orderBy?: IntegranteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  firstname: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  fullname: () => Promise<AsyncIterator<String>>;
  employeeNumber: () => Promise<AsyncIterator<String>>;
  roles: <T = Promise<AsyncIterator<RoleSubscription>>>(
    args?: {
      where?: RoleWhereInput;
      orderBy?: RoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  integrantes: <T = Promise<AsyncIterator<IntegranteSubscription>>>(
    args?: {
      where?: IntegranteWhereInput;
      orderBy?: IntegranteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateAnno {
  count: Int;
}

export interface AggregateAnnoPromise
  extends Promise<AggregateAnno>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAnnoSubscription
  extends Promise<AsyncIterator<AggregateAnno>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Integrante {
  id: ID_Output;
  jefeProyecto: Boolean;
}

export interface IntegrantePromise extends Promise<Integrante>, Fragmentable {
  id: () => Promise<ID_Output>;
  usuario: <T = UserPromise>() => T;
  proyecto: <T = ProyectoPromise>() => T;
  jefeProyecto: () => Promise<Boolean>;
  pagos: <T = FragmentableArray<Pago>>(
    args?: {
      where?: PagoWhereInput;
      orderBy?: PagoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface IntegranteSubscription
  extends Promise<AsyncIterator<Integrante>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  usuario: <T = UserSubscription>() => T;
  proyecto: <T = ProyectoSubscription>() => T;
  jefeProyecto: () => Promise<AsyncIterator<Boolean>>;
  pagos: <T = Promise<AsyncIterator<PagoSubscription>>>(
    args?: {
      where?: PagoWhereInput;
      orderBy?: PagoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTipo {
  count: Int;
}

export interface AggregateTipoPromise
  extends Promise<AggregateTipo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTipoSubscription
  extends Promise<AsyncIterator<AggregateTipo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RolePreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
}

export interface RolePreviousValuesPromise
  extends Promise<RolePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface RolePreviousValuesSubscription
  extends Promise<AsyncIterator<RolePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface TipoConnection {
  pageInfo: PageInfo;
  edges: TipoEdge[];
}

export interface TipoConnectionPromise
  extends Promise<TipoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TipoEdge>>() => T;
  aggregate: <T = AggregateTipoPromise>() => T;
}

export interface TipoConnectionSubscription
  extends Promise<AsyncIterator<TipoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TipoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTipoSubscription>() => T;
}

export interface TipoEdge {
  node: Tipo;
  cursor: String;
}

export interface TipoEdgePromise extends Promise<TipoEdge>, Fragmentable {
  node: <T = TipoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TipoEdgeSubscription
  extends Promise<AsyncIterator<TipoEdge>>,
    Fragmentable {
  node: <T = TipoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RoleEdge {
  node: Role;
  cursor: String;
}

export interface RoleEdgePromise extends Promise<RoleEdge>, Fragmentable {
  node: <T = RolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoleEdgeSubscription
  extends Promise<AsyncIterator<RoleEdge>>,
    Fragmentable {
  node: <T = RoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Alcance {
  id: ID_Output;
  nombre: String;
  valor: Int;
}

export interface AlcancePromise extends Promise<Alcance>, Fragmentable {
  id: () => Promise<ID_Output>;
  nombre: () => Promise<String>;
  valor: () => Promise<Int>;
}

export interface AlcanceSubscription
  extends Promise<AsyncIterator<Alcance>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nombre: () => Promise<AsyncIterator<String>>;
  valor: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateProyecto {
  count: Int;
}

export interface AggregateProyectoPromise
  extends Promise<AggregateProyecto>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProyectoSubscription
  extends Promise<AsyncIterator<AggregateProyecto>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AlcanceSubscriptionPayload {
  mutation: MutationType;
  node: Alcance;
  updatedFields: String[];
  previousValues: AlcancePreviousValues;
}

export interface AlcanceSubscriptionPayloadPromise
  extends Promise<AlcanceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AlcancePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AlcancePreviousValuesPromise>() => T;
}

export interface AlcanceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AlcanceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AlcanceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AlcancePreviousValuesSubscription>() => T;
}

export interface ProyectoConnection {
  pageInfo: PageInfo;
  edges: ProyectoEdge[];
}

export interface ProyectoConnectionPromise
  extends Promise<ProyectoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProyectoEdge>>() => T;
  aggregate: <T = AggregateProyectoPromise>() => T;
}

export interface ProyectoConnectionSubscription
  extends Promise<AsyncIterator<ProyectoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProyectoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProyectoSubscription>() => T;
}

export interface AlcancePreviousValues {
  id: ID_Output;
  nombre: String;
  valor: Int;
}

export interface AlcancePreviousValuesPromise
  extends Promise<AlcancePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nombre: () => Promise<String>;
  valor: () => Promise<Int>;
}

export interface AlcancePreviousValuesSubscription
  extends Promise<AsyncIterator<AlcancePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nombre: () => Promise<AsyncIterator<String>>;
  valor: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePago {
  count: Int;
}

export interface AggregatePagoPromise
  extends Promise<AggregatePago>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePagoSubscription
  extends Promise<AsyncIterator<AggregatePago>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface PagoConnection {
  pageInfo: PageInfo;
  edges: PagoEdge[];
}

export interface PagoConnectionPromise
  extends Promise<PagoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PagoEdge>>() => T;
  aggregate: <T = AggregatePagoPromise>() => T;
}

export interface PagoConnectionSubscription
  extends Promise<AsyncIterator<PagoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PagoEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePagoSubscription>() => T;
}

export interface AnnoSubscriptionPayload {
  mutation: MutationType;
  node: Anno;
  updatedFields: String[];
  previousValues: AnnoPreviousValues;
}

export interface AnnoSubscriptionPayloadPromise
  extends Promise<AnnoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AnnoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AnnoPreviousValuesPromise>() => T;
}

export interface AnnoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AnnoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AnnoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AnnoPreviousValuesSubscription>() => T;
}

export interface MesEdge {
  node: Mes;
  cursor: String;
}

export interface MesEdgePromise extends Promise<MesEdge>, Fragmentable {
  node: <T = MesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MesEdgeSubscription
  extends Promise<AsyncIterator<MesEdge>>,
    Fragmentable {
  node: <T = MesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AnnoPreviousValues {
  id: ID_Output;
  numero: Int;
  habilitado: Boolean;
}

export interface AnnoPreviousValuesPromise
  extends Promise<AnnoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  numero: () => Promise<Int>;
  habilitado: () => Promise<Boolean>;
}

export interface AnnoPreviousValuesSubscription
  extends Promise<AsyncIterator<AnnoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  numero: () => Promise<AsyncIterator<Int>>;
  habilitado: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateLinea {
  count: Int;
}

export interface AggregateLineaPromise
  extends Promise<AggregateLinea>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLineaSubscription
  extends Promise<AsyncIterator<AggregateLinea>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface File {
  id: ID_Output;
  path: String;
  filename: String;
  mimetype: String;
  encoding: String;
  size: Int;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<ID_Output>;
  path: () => Promise<String>;
  filename: () => Promise<String>;
  mimetype: () => Promise<String>;
  encoding: () => Promise<String>;
  size: () => Promise<Int>;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  path: () => Promise<AsyncIterator<String>>;
  filename: () => Promise<AsyncIterator<String>>;
  mimetype: () => Promise<AsyncIterator<String>>;
  encoding: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
}

export interface LineaConnection {
  pageInfo: PageInfo;
  edges: LineaEdge[];
}

export interface LineaConnectionPromise
  extends Promise<LineaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LineaEdge>>() => T;
  aggregate: <T = AggregateLineaPromise>() => T;
}

export interface LineaConnectionSubscription
  extends Promise<AsyncIterator<LineaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LineaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLineaSubscription>() => T;
}

export interface AreaSubscriptionPayload {
  mutation: MutationType;
  node: Area;
  updatedFields: String[];
  previousValues: AreaPreviousValues;
}

export interface AreaSubscriptionPayloadPromise
  extends Promise<AreaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AreaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AreaPreviousValuesPromise>() => T;
}

export interface AreaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AreaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AreaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AreaPreviousValuesSubscription>() => T;
}

export interface AggregateIntegrante {
  count: Int;
}

export interface AggregateIntegrantePromise
  extends Promise<AggregateIntegrante>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIntegranteSubscription
  extends Promise<AsyncIterator<AggregateIntegrante>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AreaPreviousValues {
  id: ID_Output;
  nombre: String;
}

export interface AreaPreviousValuesPromise
  extends Promise<AreaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nombre: () => Promise<String>;
}

export interface AreaPreviousValuesSubscription
  extends Promise<AsyncIterator<AreaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nombre: () => Promise<AsyncIterator<String>>;
}

export interface IntegranteConnection {
  pageInfo: PageInfo;
  edges: IntegranteEdge[];
}

export interface IntegranteConnectionPromise
  extends Promise<IntegranteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IntegranteEdge>>() => T;
  aggregate: <T = AggregateIntegrantePromise>() => T;
}

export interface IntegranteConnectionSubscription
  extends Promise<AsyncIterator<IntegranteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<IntegranteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateIntegranteSubscription>() => T;
}

export interface AggregateEje {
  count: Int;
}

export interface AggregateEjePromise
  extends Promise<AggregateEje>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEjeSubscription
  extends Promise<AsyncIterator<AggregateEje>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Pago {
  id: ID_Output;
  horas: Float;
  presencia: Int;
  incidencia: Int;
  relevancia: Int;
  complejidad: Int;
  gestion: Int;
  vinculacion: Int;
  calidad: Int;
  significacion: Int;
  cumplimiento: Int;
  calculo: Float;
}

export interface PagoPromise extends Promise<Pago>, Fragmentable {
  id: () => Promise<ID_Output>;
  integrante: <T = IntegrantePromise>() => T;
  mes: <T = MesPromise>() => T;
  anno: <T = AnnoPromise>() => T;
  horas: () => Promise<Float>;
  presencia: () => Promise<Int>;
  incidencia: () => Promise<Int>;
  relevancia: () => Promise<Int>;
  complejidad: () => Promise<Int>;
  gestion: () => Promise<Int>;
  vinculacion: () => Promise<Int>;
  calidad: () => Promise<Int>;
  significacion: () => Promise<Int>;
  cumplimiento: () => Promise<Int>;
  calculo: () => Promise<Float>;
}

export interface PagoSubscription
  extends Promise<AsyncIterator<Pago>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  integrante: <T = IntegranteSubscription>() => T;
  mes: <T = MesSubscription>() => T;
  anno: <T = AnnoSubscription>() => T;
  horas: () => Promise<AsyncIterator<Float>>;
  presencia: () => Promise<AsyncIterator<Int>>;
  incidencia: () => Promise<AsyncIterator<Int>>;
  relevancia: () => Promise<AsyncIterator<Int>>;
  complejidad: () => Promise<AsyncIterator<Int>>;
  gestion: () => Promise<AsyncIterator<Int>>;
  vinculacion: () => Promise<AsyncIterator<Int>>;
  calidad: () => Promise<AsyncIterator<Int>>;
  significacion: () => Promise<AsyncIterator<Int>>;
  cumplimiento: () => Promise<AsyncIterator<Int>>;
  calculo: () => Promise<AsyncIterator<Float>>;
}

export interface EjeSubscriptionPayload {
  mutation: MutationType;
  node: Eje;
  updatedFields: String[];
  previousValues: EjePreviousValues;
}

export interface EjeSubscriptionPayloadPromise
  extends Promise<EjeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EjePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EjePreviousValuesPromise>() => T;
}

export interface EjeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EjeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EjeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EjePreviousValuesSubscription>() => T;
}

export interface Linea {
  id: ID_Output;
  nombre: String;
}

export interface LineaPromise extends Promise<Linea>, Fragmentable {
  id: () => Promise<ID_Output>;
  nombre: () => Promise<String>;
}

export interface LineaSubscription
  extends Promise<AsyncIterator<Linea>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nombre: () => Promise<AsyncIterator<String>>;
}

export interface EjePreviousValues {
  id: ID_Output;
  nombre: String;
}

export interface EjePreviousValuesPromise
  extends Promise<EjePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nombre: () => Promise<String>;
}

export interface EjePreviousValuesSubscription
  extends Promise<AsyncIterator<EjePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nombre: () => Promise<AsyncIterator<String>>;
}

export interface Proyecto {
  id: ID_Output;
  codigo: String;
  nombre: String;
  inicia: DateTimeOutput;
  finaliza: DateTimeOutput;
  estado: ESTADO;
}

export interface ProyectoPromise extends Promise<Proyecto>, Fragmentable {
  id: () => Promise<ID_Output>;
  codigo: () => Promise<String>;
  nombre: () => Promise<String>;
  inicia: () => Promise<DateTimeOutput>;
  finaliza: () => Promise<DateTimeOutput>;
  area: <T = AreaPromise>() => T;
  tipo: <T = TipoPromise>() => T;
  linea: <T = LineaPromise>() => T;
  eje: <T = EjePromise>() => T;
  alcance: <T = AlcancePromise>() => T;
  estado: () => Promise<ESTADO>;
  integrantes: <T = FragmentableArray<Integrante>>(
    args?: {
      where?: IntegranteWhereInput;
      orderBy?: IntegranteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProyectoSubscription
  extends Promise<AsyncIterator<Proyecto>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  codigo: () => Promise<AsyncIterator<String>>;
  nombre: () => Promise<AsyncIterator<String>>;
  inicia: () => Promise<AsyncIterator<DateTimeOutput>>;
  finaliza: () => Promise<AsyncIterator<DateTimeOutput>>;
  area: <T = AreaSubscription>() => T;
  tipo: <T = TipoSubscription>() => T;
  linea: <T = LineaSubscription>() => T;
  eje: <T = EjeSubscription>() => T;
  alcance: <T = AlcanceSubscription>() => T;
  estado: () => Promise<AsyncIterator<ESTADO>>;
  integrantes: <T = Promise<AsyncIterator<IntegranteSubscription>>>(
    args?: {
      where?: IntegranteWhereInput;
      orderBy?: IntegranteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface EjeEdge {
  node: Eje;
  cursor: String;
}

export interface EjeEdgePromise extends Promise<EjeEdge>, Fragmentable {
  node: <T = EjePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EjeEdgeSubscription
  extends Promise<AsyncIterator<EjeEdge>>,
    Fragmentable {
  node: <T = EjeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AlcanceEdge {
  node: Alcance;
  cursor: String;
}

export interface AlcanceEdgePromise extends Promise<AlcanceEdge>, Fragmentable {
  node: <T = AlcancePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AlcanceEdgeSubscription
  extends Promise<AsyncIterator<AlcanceEdge>>,
    Fragmentable {
  node: <T = AlcanceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface AggregateAlcance {
  count: Int;
}

export interface AggregateAlcancePromise
  extends Promise<AggregateAlcance>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAlcanceSubscription
  extends Promise<AsyncIterator<AggregateAlcance>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FilePreviousValues {
  id: ID_Output;
  path: String;
  filename: String;
  mimetype: String;
  encoding: String;
  size: Int;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  path: () => Promise<String>;
  filename: () => Promise<String>;
  mimetype: () => Promise<String>;
  encoding: () => Promise<String>;
  size: () => Promise<Int>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  path: () => Promise<AsyncIterator<String>>;
  filename: () => Promise<AsyncIterator<String>>;
  mimetype: () => Promise<AsyncIterator<String>>;
  encoding: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
}

export interface Anno {
  id: ID_Output;
  numero: Int;
  habilitado: Boolean;
}

export interface AnnoPromise extends Promise<Anno>, Fragmentable {
  id: () => Promise<ID_Output>;
  numero: () => Promise<Int>;
  habilitado: () => Promise<Boolean>;
}

export interface AnnoSubscription
  extends Promise<AsyncIterator<Anno>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  numero: () => Promise<AsyncIterator<Int>>;
  habilitado: () => Promise<AsyncIterator<Boolean>>;
}

export interface EjeConnection {
  pageInfo: PageInfo;
  edges: EjeEdge[];
}

export interface EjeConnectionPromise
  extends Promise<EjeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EjeEdge>>() => T;
  aggregate: <T = AggregateEjePromise>() => T;
}

export interface EjeConnectionSubscription
  extends Promise<AsyncIterator<EjeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EjeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEjeSubscription>() => T;
}

export interface AnnoEdge {
  node: Anno;
  cursor: String;
}

export interface AnnoEdgePromise extends Promise<AnnoEdge>, Fragmentable {
  node: <T = AnnoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AnnoEdgeSubscription
  extends Promise<AsyncIterator<AnnoEdge>>,
    Fragmentable {
  node: <T = AnnoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface IntegranteSubscriptionPayload {
  mutation: MutationType;
  node: Integrante;
  updatedFields: String[];
  previousValues: IntegrantePreviousValues;
}

export interface IntegranteSubscriptionPayloadPromise
  extends Promise<IntegranteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IntegrantePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IntegrantePreviousValuesPromise>() => T;
}

export interface IntegranteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IntegranteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IntegranteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IntegrantePreviousValuesSubscription>() => T;
}

export interface RoleConnection {
  pageInfo: PageInfo;
  edges: RoleEdge[];
}

export interface RoleConnectionPromise
  extends Promise<RoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoleEdge>>() => T;
  aggregate: <T = AggregateRolePromise>() => T;
}

export interface RoleConnectionSubscription
  extends Promise<AsyncIterator<RoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoleSubscription>() => T;
}

export interface IntegrantePreviousValues {
  id: ID_Output;
  jefeProyecto: Boolean;
}

export interface IntegrantePreviousValuesPromise
  extends Promise<IntegrantePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  jefeProyecto: () => Promise<Boolean>;
}

export interface IntegrantePreviousValuesSubscription
  extends Promise<AsyncIterator<IntegrantePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  jefeProyecto: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface AnnoConnection {
  pageInfo: PageInfo;
  edges: AnnoEdge[];
}

export interface AnnoConnectionPromise
  extends Promise<AnnoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AnnoEdge>>() => T;
  aggregate: <T = AggregateAnnoPromise>() => T;
}

export interface AnnoConnectionSubscription
  extends Promise<AsyncIterator<AnnoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AnnoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAnnoSubscription>() => T;
}

export interface AggregateMes {
  count: Int;
}

export interface AggregateMesPromise
  extends Promise<AggregateMes>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMesSubscription
  extends Promise<AsyncIterator<AggregateMes>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LineaSubscriptionPayload {
  mutation: MutationType;
  node: Linea;
  updatedFields: String[];
  previousValues: LineaPreviousValues;
}

export interface LineaSubscriptionPayloadPromise
  extends Promise<LineaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LineaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LineaPreviousValuesPromise>() => T;
}

export interface LineaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LineaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LineaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LineaPreviousValuesSubscription>() => T;
}

export interface LineaEdge {
  node: Linea;
  cursor: String;
}

export interface LineaEdgePromise extends Promise<LineaEdge>, Fragmentable {
  node: <T = LineaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LineaEdgeSubscription
  extends Promise<AsyncIterator<LineaEdge>>,
    Fragmentable {
  node: <T = LineaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LineaPreviousValues {
  id: ID_Output;
  nombre: String;
}

export interface LineaPreviousValuesPromise
  extends Promise<LineaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nombre: () => Promise<String>;
}

export interface LineaPreviousValuesSubscription
  extends Promise<AsyncIterator<LineaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nombre: () => Promise<AsyncIterator<String>>;
}

export interface IntegranteEdge {
  node: Integrante;
  cursor: String;
}

export interface IntegranteEdgePromise
  extends Promise<IntegranteEdge>,
    Fragmentable {
  node: <T = IntegrantePromise>() => T;
  cursor: () => Promise<String>;
}

export interface IntegranteEdgeSubscription
  extends Promise<AsyncIterator<IntegranteEdge>>,
    Fragmentable {
  node: <T = IntegranteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Eje {
  id: ID_Output;
  nombre: String;
}

export interface EjePromise extends Promise<Eje>, Fragmentable {
  id: () => Promise<ID_Output>;
  nombre: () => Promise<String>;
}

export interface EjeSubscription
  extends Promise<AsyncIterator<Eje>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nombre: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface MesSubscriptionPayload {
  mutation: MutationType;
  node: Mes;
  updatedFields: String[];
  previousValues: MesPreviousValues;
}

export interface MesSubscriptionPayloadPromise
  extends Promise<MesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MesPreviousValuesPromise>() => T;
}

export interface MesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MesPreviousValuesSubscription>() => T;
}

export interface Area {
  id: ID_Output;
  nombre: String;
}

export interface AreaPromise extends Promise<Area>, Fragmentable {
  id: () => Promise<ID_Output>;
  nombre: () => Promise<String>;
}

export interface AreaSubscription
  extends Promise<AsyncIterator<Area>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nombre: () => Promise<AsyncIterator<String>>;
}

export interface MesPreviousValues {
  id: ID_Output;
  nombre: MES_ENUM;
  habilitado: Boolean;
}

export interface MesPreviousValuesPromise
  extends Promise<MesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nombre: () => Promise<MES_ENUM>;
  habilitado: () => Promise<Boolean>;
}

export interface MesPreviousValuesSubscription
  extends Promise<AsyncIterator<MesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nombre: () => Promise<AsyncIterator<MES_ENUM>>;
  habilitado: () => Promise<AsyncIterator<Boolean>>;
}

export interface TipoPreviousValues {
  id: ID_Output;
  nombre: String;
}

export interface TipoPreviousValuesPromise
  extends Promise<TipoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nombre: () => Promise<String>;
}

export interface TipoPreviousValuesSubscription
  extends Promise<AsyncIterator<TipoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nombre: () => Promise<AsyncIterator<String>>;
}

export interface AggregateArea {
  count: Int;
}

export interface AggregateAreaPromise
  extends Promise<AggregateArea>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAreaSubscription
  extends Promise<AsyncIterator<AggregateArea>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateRole {
  count: Int;
}

export interface AggregateRolePromise
  extends Promise<AggregateRole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoleSubscription
  extends Promise<AsyncIterator<AggregateRole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PagoSubscriptionPayload {
  mutation: MutationType;
  node: Pago;
  updatedFields: String[];
  previousValues: PagoPreviousValues;
}

export interface PagoSubscriptionPayloadPromise
  extends Promise<PagoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PagoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PagoPreviousValuesPromise>() => T;
}

export interface PagoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PagoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PagoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PagoPreviousValuesSubscription>() => T;
}

export interface PagoEdge {
  node: Pago;
  cursor: String;
}

export interface PagoEdgePromise extends Promise<PagoEdge>, Fragmentable {
  node: <T = PagoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PagoEdgeSubscription
  extends Promise<AsyncIterator<PagoEdge>>,
    Fragmentable {
  node: <T = PagoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PagoPreviousValues {
  id: ID_Output;
  horas: Float;
  presencia: Int;
  incidencia: Int;
  relevancia: Int;
  complejidad: Int;
  gestion: Int;
  vinculacion: Int;
  calidad: Int;
  significacion: Int;
  cumplimiento: Int;
  calculo: Float;
}

export interface PagoPreviousValuesPromise
  extends Promise<PagoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  horas: () => Promise<Float>;
  presencia: () => Promise<Int>;
  incidencia: () => Promise<Int>;
  relevancia: () => Promise<Int>;
  complejidad: () => Promise<Int>;
  gestion: () => Promise<Int>;
  vinculacion: () => Promise<Int>;
  calidad: () => Promise<Int>;
  significacion: () => Promise<Int>;
  cumplimiento: () => Promise<Int>;
  calculo: () => Promise<Float>;
}

export interface PagoPreviousValuesSubscription
  extends Promise<AsyncIterator<PagoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  horas: () => Promise<AsyncIterator<Float>>;
  presencia: () => Promise<AsyncIterator<Int>>;
  incidencia: () => Promise<AsyncIterator<Int>>;
  relevancia: () => Promise<AsyncIterator<Int>>;
  complejidad: () => Promise<AsyncIterator<Int>>;
  gestion: () => Promise<AsyncIterator<Int>>;
  vinculacion: () => Promise<AsyncIterator<Int>>;
  calidad: () => Promise<AsyncIterator<Int>>;
  significacion: () => Promise<AsyncIterator<Int>>;
  cumplimiento: () => Promise<AsyncIterator<Int>>;
  calculo: () => Promise<AsyncIterator<Float>>;
}

export interface AlcanceConnection {
  pageInfo: PageInfo;
  edges: AlcanceEdge[];
}

export interface AlcanceConnectionPromise
  extends Promise<AlcanceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AlcanceEdge>>() => T;
  aggregate: <T = AggregateAlcancePromise>() => T;
}

export interface AlcanceConnectionSubscription
  extends Promise<AsyncIterator<AlcanceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AlcanceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAlcanceSubscription>() => T;
}

export interface AreaEdge {
  node: Area;
  cursor: String;
}

export interface AreaEdgePromise extends Promise<AreaEdge>, Fragmentable {
  node: <T = AreaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AreaEdgeSubscription
  extends Promise<AsyncIterator<AreaEdge>>,
    Fragmentable {
  node: <T = AreaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Tipo {
  id: ID_Output;
  nombre: String;
}

export interface TipoPromise extends Promise<Tipo>, Fragmentable {
  id: () => Promise<ID_Output>;
  nombre: () => Promise<String>;
}

export interface TipoSubscription
  extends Promise<AsyncIterator<Tipo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nombre: () => Promise<AsyncIterator<String>>;
}

export interface TipoSubscriptionPayload {
  mutation: MutationType;
  node: Tipo;
  updatedFields: String[];
  previousValues: TipoPreviousValues;
}

export interface TipoSubscriptionPayloadPromise
  extends Promise<TipoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TipoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TipoPreviousValuesPromise>() => T;
}

export interface TipoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TipoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TipoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TipoPreviousValuesSubscription>() => T;
}

export interface RoleSubscriptionPayload {
  mutation: MutationType;
  node: Role;
  updatedFields: String[];
  previousValues: RolePreviousValues;
}

export interface RoleSubscriptionPayloadPromise
  extends Promise<RoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RolePreviousValuesPromise>() => T;
}

export interface RoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RolePreviousValuesSubscription>() => T;
}

export interface AreaConnection {
  pageInfo: PageInfo;
  edges: AreaEdge[];
}

export interface AreaConnectionPromise
  extends Promise<AreaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AreaEdge>>() => T;
  aggregate: <T = AggregateAreaPromise>() => T;
}

export interface AreaConnectionSubscription
  extends Promise<AsyncIterator<AreaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AreaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAreaSubscription>() => T;
}

export interface ProyectoPreviousValues {
  id: ID_Output;
  codigo: String;
  nombre: String;
  inicia: DateTimeOutput;
  finaliza: DateTimeOutput;
  estado: ESTADO;
}

export interface ProyectoPreviousValuesPromise
  extends Promise<ProyectoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  codigo: () => Promise<String>;
  nombre: () => Promise<String>;
  inicia: () => Promise<DateTimeOutput>;
  finaliza: () => Promise<DateTimeOutput>;
  estado: () => Promise<ESTADO>;
}

export interface ProyectoPreviousValuesSubscription
  extends Promise<AsyncIterator<ProyectoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  codigo: () => Promise<AsyncIterator<String>>;
  nombre: () => Promise<AsyncIterator<String>>;
  inicia: () => Promise<AsyncIterator<DateTimeOutput>>;
  finaliza: () => Promise<AsyncIterator<DateTimeOutput>>;
  estado: () => Promise<AsyncIterator<ESTADO>>;
}

export interface ProyectoSubscriptionPayload {
  mutation: MutationType;
  node: Proyecto;
  updatedFields: String[];
  previousValues: ProyectoPreviousValues;
}

export interface ProyectoSubscriptionPayloadPromise
  extends Promise<ProyectoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProyectoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProyectoPreviousValuesPromise>() => T;
}

export interface ProyectoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProyectoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProyectoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProyectoPreviousValuesSubscription>() => T;
}

export interface ProyectoEdge {
  node: Proyecto;
  cursor: String;
}

export interface ProyectoEdgePromise
  extends Promise<ProyectoEdge>,
    Fragmentable {
  node: <T = ProyectoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProyectoEdgeSubscription
  extends Promise<AsyncIterator<ProyectoEdge>>,
    Fragmentable {
  node: <T = ProyectoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Role {
  id: ID_Output;
  name: String;
  description?: String;
}

export interface RolePromise extends Promise<Role>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface RoleSubscription
  extends Promise<AsyncIterator<Role>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Mes {
  id: ID_Output;
  nombre: MES_ENUM;
  habilitado: Boolean;
}

export interface MesPromise extends Promise<Mes>, Fragmentable {
  id: () => Promise<ID_Output>;
  nombre: () => Promise<MES_ENUM>;
  habilitado: () => Promise<Boolean>;
}

export interface MesSubscription
  extends Promise<AsyncIterator<Mes>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nombre: () => Promise<AsyncIterator<MES_ENUM>>;
  habilitado: () => Promise<AsyncIterator<Boolean>>;
}

export interface MesConnection {
  pageInfo: PageInfo;
  edges: MesEdge[];
}

export interface MesConnectionPromise
  extends Promise<MesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MesEdge>>() => T;
  aggregate: <T = AggregateMesPromise>() => T;
}

export interface MesConnectionSubscription
  extends Promise<AsyncIterator<MesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMesSubscription>() => T;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  },
  {
    name: "Proyecto",
    embedded: false
  },
  {
    name: "Integrante",
    embedded: false
  },
  {
    name: "Pago",
    embedded: false
  },
  {
    name: "ESTADO",
    embedded: false
  },
  {
    name: "Mes",
    embedded: false
  },
  {
    name: "MES_ENUM",
    embedded: false
  },
  {
    name: "Anno",
    embedded: false
  },
  {
    name: "Area",
    embedded: false
  },
  {
    name: "Eje",
    embedded: false
  },
  {
    name: "Linea",
    embedded: false
  },
  {
    name: "Tipo",
    embedded: false
  },
  {
    name: "Alcance",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
